\section{Request params}
\label{group__params}\index{Request params@{Request params}}
\subsection*{Data Structures}
\begin{CompactItemize}
\item 
struct {\bf apreq\_\-hook\_\-t}
\item 
struct {\bf apreq\_\-param\_\-t}
\item 
struct {\bf apreq\_\-parser\_\-t}
\item 
struct {\bf apreq\_\-request\_\-t}
\end{CompactItemize}
\subsection*{Defines}
\begin{CompactItemize}
\item 
\#define {\bf apreq\_\-value\_\-to\_\-param}(ptr)\ apreq\_\-attr\_\-to\_\-type({\bf apreq\_\-param\_\-t}, v, ptr)
\item 
\index{apreq_param_name@{apreq\_\-param\_\-name}!params@{params}}\index{params@{params}!apreq_param_name@{apreq\_\-param\_\-name}}
\#define {\bf apreq\_\-param\_\-name}(p)\ ((p) $\rightarrow$ v.name)\label{group__params_a23}

\item 
\index{apreq_param_value@{apreq\_\-param\_\-value}!params@{params}}\index{params@{params}!apreq_param_value@{apreq\_\-param\_\-value}}
\#define {\bf apreq\_\-param\_\-value}(p)\ ((p) $\rightarrow$ v.data)\label{group__params_a24}

\item 
\index{apreq_param_info@{apreq\_\-param\_\-info}!params@{params}}\index{params@{params}!apreq_param_info@{apreq\_\-param\_\-info}}
\#define {\bf apreq\_\-param\_\-info}(p)\ ((p) $\rightarrow$ info)\label{group__params_a25}

\item 
\index{apreq_param_status@{apreq\_\-param\_\-status}!params@{params}}\index{params@{params}!apreq_param_status@{apreq\_\-param\_\-status}}
\#define {\bf apreq\_\-param\_\-status}(p)\ ((p) $\rightarrow$ v.status)\label{group__params_a26}

\item 
\index{apreq_param_brigade@{apreq\_\-param\_\-brigade}!params@{params}}\index{params@{params}!apreq_param_brigade@{apreq\_\-param\_\-brigade}}
\#define {\bf apreq\_\-param\_\-brigade}(p)\ ((p) $\rightarrow$ bb ? apreq\_\-copy\_\-brigade((p) $\rightarrow$ bb) : NULL)\label{group__params_a27}

\item 
\#define {\bf APREQ\_\-PARSER\_\-ARGS}
\item 
\#define {\bf APREQ\_\-HOOK\_\-ARGS}
\item 
\#define {\bf APREQ\_\-DECLARE\_\-PARSER}(f)
\item 
\#define {\bf APREQ\_\-DECLARE\_\-HOOK}(f)
\item 
\#define {\bf APREQ\_\-RUN\_\-PARSER}(psr, env, t, bb)\ (psr) $\rightarrow$ parser(psr,env,t,bb)
\item 
\#define {\bf APREQ\_\-RUN\_\-HOOK}(h, env, param, bb)\ (h) $\rightarrow$ hook(h,env,param,bb)
\end{CompactItemize}
\subsection*{Typedefs}
\begin{CompactItemize}
\item 
typedef apreq\_\-param\_\-t {\bf apreq\_\-param\_\-t}
\item 
\index{apreq_hook_t@{apreq\_\-hook\_\-t}!params@{params}}\index{params@{params}!apreq_hook_t@{apreq\_\-hook\_\-t}}
typedef apreq\_\-hook\_\-t {\bf apreq\_\-hook\_\-t}\label{group__params_a1}

\item 
\index{apreq_parser_t@{apreq\_\-parser\_\-t}!params@{params}}\index{params@{params}!apreq_parser_t@{apreq\_\-parser\_\-t}}
typedef apreq\_\-parser\_\-t {\bf apreq\_\-parser\_\-t}\label{group__params_a2}

\item 
typedef apreq\_\-request\_\-t {\bf apreq\_\-request\_\-t}
\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\bf apreq\_\-param\_\-t} $\ast$ {\bf apreq\_\-make\_\-param} ({\bf apr\_\-pool\_\-t} $\ast$p, const char $\ast$name, const {\bf apr\_\-size\_\-t} nlen, const char $\ast$val, const {\bf apr\_\-size\_\-t} vlen)
\item 
{\bf apreq\_\-request\_\-t} $\ast$ {\bf apreq\_\-request} ({\bf void} $\ast$env, const char $\ast$qs)
\item 
{\bf apreq\_\-param\_\-t} $\ast$ {\bf apreq\_\-param} (const {\bf apreq\_\-request\_\-t} $\ast$req, const char $\ast$name)
\item 
{\bf apr\_\-table\_\-t} $\ast$ {\bf apreq\_\-params} ({\bf apr\_\-pool\_\-t} $\ast$pool, const {\bf apreq\_\-request\_\-t} $\ast$req)
\item 
{\bf apr\_\-array\_\-header\_\-t} $\ast$ {\bf apreq\_\-params\_\-as\_\-array} ({\bf apr\_\-pool\_\-t} $\ast$p, {\bf apreq\_\-request\_\-t} $\ast$req, const char $\ast${\bf key})
\item 
const char $\ast$ {\bf apreq\_\-params\_\-as\_\-string} ({\bf apr\_\-pool\_\-t} $\ast$p, {\bf apreq\_\-request\_\-t} $\ast$req, const char $\ast${\bf key}, {\bf apreq\_\-join\_\-t} mode)
\item 
{\bf apreq\_\-param\_\-t} $\ast$ {\bf apreq\_\-decode\_\-param} ({\bf apr\_\-pool\_\-t} $\ast$pool, const char $\ast$word, const {\bf apr\_\-size\_\-t} nlen, const {\bf apr\_\-size\_\-t} vlen)
\item 
char $\ast$ {\bf apreq\_\-encode\_\-param} ({\bf apr\_\-pool\_\-t} $\ast$pool, const {\bf apreq\_\-param\_\-t} $\ast$param)
\item 
{\bf apr\_\-status\_\-t} {\bf apreq\_\-parse\_\-query\_\-string} ({\bf apr\_\-pool\_\-t} $\ast$pool, {\bf apr\_\-table\_\-t} $\ast$t, const char $\ast$qs)
\item 
{\bf apr\_\-status\_\-t} {\bf apreq\_\-parse\_\-request} ({\bf apreq\_\-request\_\-t} $\ast$req, {\bf apr\_\-bucket\_\-brigade} $\ast$bb)
\item 
{\bf apr\_\-table\_\-t} $\ast$ {\bf apreq\_\-uploads} ({\bf apr\_\-pool\_\-t} $\ast$pool, const {\bf apreq\_\-request\_\-t} $\ast$req)
\item 
{\bf apreq\_\-param\_\-t} $\ast$ {\bf apreq\_\-upload} (const {\bf apreq\_\-request\_\-t} $\ast$req, const char $\ast${\bf key})
\item 
{\bf apr\_\-status\_\-t} {\bf apreq\_\-brigade\_\-concat} ({\bf void} $\ast$env, {\bf apr\_\-bucket\_\-brigade} $\ast$out, {\bf apr\_\-bucket\_\-brigade} $\ast$in)
\item 
{\bf APREQ\_\-DECLARE\_\-PARSER} (apreq\_\-parse\_\-headers)
\item 
{\bf apreq\_\-parser\_\-t} $\ast$ {\bf apreq\_\-make\_\-parser} ({\bf apr\_\-pool\_\-t} $\ast$pool, const char $\ast$enctype, {\bf apr\_\-status\_\-t}($\ast$parser) APREQ\_\-PARSER\_\-ARGS, {\bf apreq\_\-hook\_\-t} $\ast$hook, {\bf void} $\ast$ctx)
\item 
{\bf apreq\_\-hook\_\-t} $\ast$ {\bf apreq\_\-make\_\-hook} ({\bf apr\_\-pool\_\-t} $\ast$pool, {\bf apr\_\-status\_\-t}($\ast$hook) APREQ\_\-HOOK\_\-ARGS, {\bf apreq\_\-hook\_\-t} $\ast$next, {\bf void} $\ast$ctx)
\item 
{\bf void} {\bf apreq\_\-add\_\-hook} ({\bf apreq\_\-parser\_\-t} $\ast$p, {\bf apreq\_\-hook\_\-t} $\ast$h)
\item 
{\bf apreq\_\-parser\_\-t} $\ast$ {\bf apreq\_\-parser} ({\bf void} $\ast$env, {\bf apreq\_\-hook\_\-t} $\ast$hook)
\end{CompactItemize}


\subsection{Define Documentation}
\index{params@{params}!APREQ_DECLARE_HOOK@{APREQ\_\-DECLARE\_\-HOOK}}
\index{APREQ_DECLARE_HOOK@{APREQ\_\-DECLARE\_\-HOOK}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define APREQ\_\-DECLARE\_\-HOOK(f)}\label{group__params_a31}


{\bf Value:}

\footnotesize\begin{verbatim}APREQ_DECLARE(apr_status_t) \
                                (f) APREQ_HOOK_ARGS\end{verbatim}\normalsize 
Declares an API hook. \index{params@{params}!APREQ_DECLARE_PARSER@{APREQ\_\-DECLARE\_\-PARSER}}
\index{APREQ_DECLARE_PARSER@{APREQ\_\-DECLARE\_\-PARSER}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define APREQ\_\-DECLARE\_\-PARSER(f)}\label{group__params_a30}


{\bf Value:}

\footnotesize\begin{verbatim}APREQ_DECLARE(apr_status_t) \
                                (f) APREQ_PARSER_ARGS\end{verbatim}\normalsize 
Declares a API parser. \index{params@{params}!APREQ_HOOK_ARGS@{APREQ\_\-HOOK\_\-ARGS}}
\index{APREQ_HOOK_ARGS@{APREQ\_\-HOOK\_\-ARGS}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define APREQ\_\-HOOK\_\-ARGS}\label{group__params_a29}


{\bf Value:}

\footnotesize\begin{verbatim}(apreq_hook_t *hook,         \
                           void *env,                  \
                           const apreq_param_t *param, \
                           apr_bucket_brigade *bb)\end{verbatim}\normalsize 
Hook arguments \index{params@{params}!APREQ_PARSER_ARGS@{APREQ\_\-PARSER\_\-ARGS}}
\index{APREQ_PARSER_ARGS@{APREQ\_\-PARSER\_\-ARGS}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define APREQ\_\-PARSER\_\-ARGS}\label{group__params_a28}


{\bf Value:}

\footnotesize\begin{verbatim}(apreq_parser_t *parser,     \
                           void *env,                  \
                           apr_table_t *t,             \
                           apr_bucket_brigade *bb)\end{verbatim}\normalsize 
Parser arguments. \index{params@{params}!APREQ_RUN_HOOK@{APREQ\_\-RUN\_\-HOOK}}
\index{APREQ_RUN_HOOK@{APREQ\_\-RUN\_\-HOOK}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define APREQ\_\-RUN\_\-HOOK(h, env, param, bb)\ (h) $\rightarrow$ hook(h,env,param,bb)}\label{group__params_a33}


Run the hook with the current parameter and the incoming  bucket brigade. The hook may modify the brigade if necessary. Once all hooks have completed, the contents of the brigade will  be added to the parameter's bb attribute. \index{params@{params}!APREQ_RUN_PARSER@{APREQ\_\-RUN\_\-PARSER}}
\index{APREQ_RUN_PARSER@{APREQ\_\-RUN\_\-PARSER}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define APREQ\_\-RUN\_\-PARSER(psr, env, t, bb)\ (psr) $\rightarrow$ parser(psr,env,t,bb)}\label{group__params_a32}


Parse the incoming brigade into a table. \index{params@{params}!apreq_value_to_param@{apreq\_\-value\_\-to\_\-param}}
\index{apreq_value_to_param@{apreq\_\-value\_\-to\_\-param}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define apreq\_\-value\_\-to\_\-param(ptr)\ apreq\_\-attr\_\-to\_\-type({\bf apreq\_\-param\_\-t}, v, ptr)}\label{group__params_a22}


accessor macros 

\subsection{Typedef Documentation}
\index{params@{params}!apreq_param_t@{apreq\_\-param\_\-t}}
\index{apreq_param_t@{apreq\_\-param\_\-t}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct apreq\_\-param\_\-t  apreq\_\-param\_\-t}\label{group__params_a0}


Common data structure for params and file uploads \index{params@{params}!apreq_request_t@{apreq\_\-request\_\-t}}
\index{apreq_request_t@{apreq\_\-request\_\-t}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct apreq\_\-request\_\-t  apreq\_\-request\_\-t}\label{group__params_a3}


Structure which manages the request data. 

\subsection{Function Documentation}
\index{params@{params}!apreq_add_hook@{apreq\_\-add\_\-hook}}
\index{apreq_add_hook@{apreq\_\-add\_\-hook}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf void} apreq\_\-add\_\-hook ({\bf apreq\_\-parser\_\-t} $\ast$ {\em p}, {\bf apreq\_\-hook\_\-t} $\ast$ {\em h})}\label{group__params_a20}


Add a new hook to the end of the parser's hook list.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
p}]Parser. \item[{\em 
h}]Hook to append. \end{description}
\end{Desc}
\index{params@{params}!apreq_brigade_concat@{apreq\_\-brigade\_\-concat}}
\index{apreq_brigade_concat@{apreq\_\-brigade\_\-concat}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apr\_\-status\_\-t} apreq\_\-brigade\_\-concat ({\bf void} $\ast$ {\em env}, {\bf apr\_\-bucket\_\-brigade} $\ast$ {\em out}, {\bf apr\_\-bucket\_\-brigade} $\ast$ {\em in})}\label{group__params_a16}


Concatenates the brigades, spooling large brigades into a tempfile bucket according to the environment's max\_\-brigade setting- see {\bf apreq\_\-env\_\-max\_\-brigade}() {\rm (p.\,\pageref{group__ENV_a11})}. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
env}]Environment. \item[{\em 
out}]Resulting brigade. \item[{\em 
in}]Brigade to append. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
APR\_\-SUCCESS on success, error code otherwise. \end{Desc}
\index{params@{params}!APREQ_DECLARE_PARSER@{APREQ\_\-DECLARE\_\-PARSER}}
\index{APREQ_DECLARE_PARSER@{APREQ\_\-DECLARE\_\-PARSER}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}APREQ\_\-DECLARE\_\-PARSER (apreq\_\-parse\_\-headers)}\label{group__params_a17}


Rfc822 Header parser. \index{params@{params}!apreq_decode_param@{apreq\_\-decode\_\-param}}
\index{apreq_decode_param@{apreq\_\-decode\_\-param}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apreq\_\-param\_\-t}$\ast$ apreq\_\-decode\_\-param ({\bf apr\_\-pool\_\-t} $\ast$ {\em pool}, const char $\ast$ {\em word}, const {\bf apr\_\-size\_\-t} {\em nlen}, const {\bf apr\_\-size\_\-t} {\em vlen})}\label{group__params_a10}


Url-decodes a name=value pair into a param. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
pool}]Pool from which the param is allocated. \item[{\em 
word}]Start of the name=value pair. \item[{\em 
nlen}]Length of urlencoded name. \item[{\em 
vlen}]Length of urlencoded value. \end{description}
\end{Desc}
\begin{Desc}
\item[Remarks: ]\par
Unless vlen == 0, this function assumes there is exactly one character ('=') which separates the pair. \end{Desc}
\index{params@{params}!apreq_encode_param@{apreq\_\-encode\_\-param}}
\index{apreq_encode_param@{apreq\_\-encode\_\-param}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ apreq\_\-encode\_\-param ({\bf apr\_\-pool\_\-t} $\ast$ {\em pool}, const {\bf apreq\_\-param\_\-t} $\ast$ {\em param})}\label{group__params_a11}


Url-encodes the param into a name-value pair. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
pool}]Pool which allocates the returned string. \item[{\em 
param}]Param to encode. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
name-value pair representing the param. \end{Desc}
\index{params@{params}!apreq_make_hook@{apreq\_\-make\_\-hook}}
\index{apreq_make_hook@{apreq\_\-make\_\-hook}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apreq\_\-hook\_\-t}$\ast$ apreq\_\-make\_\-hook ({\bf apr\_\-pool\_\-t} $\ast$ {\em pool}, {\bf apr\_\-status\_\-t} $\ast$hook {\em APREQ\_\-HOOK\_\-ARGS}, {\bf apreq\_\-hook\_\-t} $\ast$ {\em next}, {\bf void} $\ast$ {\em ctx})}\label{group__params_a19}


Construct a hook.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
Pool}]used to allocate the hook. \item[{\em 
hook}]The hook function. \item[{\em 
next}]List of other hooks for this hook to call on. \item[{\em 
ctx}]Hook's internal scratch pad. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
New hook. \end{Desc}
\index{params@{params}!apreq_make_param@{apreq\_\-make\_\-param}}
\index{apreq_make_param@{apreq\_\-make\_\-param}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apreq\_\-param\_\-t}$\ast$ apreq\_\-make\_\-param ({\bf apr\_\-pool\_\-t} $\ast$ {\em p}, const char $\ast$ {\em name}, const {\bf apr\_\-size\_\-t} {\em nlen}, const char $\ast$ {\em val}, const {\bf apr\_\-size\_\-t} {\em vlen})}\label{group__params_a4}


creates a param from name/value information \index{params@{params}!apreq_make_parser@{apreq\_\-make\_\-parser}}
\index{apreq_make_parser@{apreq\_\-make\_\-parser}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apreq\_\-parser\_\-t}$\ast$ apreq\_\-make\_\-parser ({\bf apr\_\-pool\_\-t} $\ast$ {\em pool}, const char $\ast$ {\em enctype}, {\bf apr\_\-status\_\-t} $\ast$parser {\em APREQ\_\-PARSER\_\-ARGS}, {\bf apreq\_\-hook\_\-t} $\ast$ {\em hook}, {\bf void} $\ast$ {\em ctx})}\label{group__params_a18}


Construct a parser.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
pool}]Pool used to allocate the parser. \item[{\em 
enctype}]Content-type that this parser can deal with. \item[{\em 
parser}]The parser function. \item[{\em 
hook}]Hooks to asssociate this parser with. \item[{\em 
ctx}]Parser's internal scratch pad. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
New parser. \end{Desc}
\index{params@{params}!apreq_param@{apreq\_\-param}}
\index{apreq_param@{apreq\_\-param}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apreq\_\-param\_\-t}$\ast$ apreq\_\-param (const {\bf apreq\_\-request\_\-t} $\ast$ {\em req}, const char $\ast$ {\em name})}\label{group__params_a6}


Returns the first parameter value for the requested key, NULL if none found. The key is case-insensitive. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
req}]The current {\bf apreq\_\-request\_\-t} {\rm (p.\,\pageref{structapreq__request__t})} object. \item[{\em 
key}]Nul-terminated search key. Returns the first table value  if NULL. \end{description}
\end{Desc}
\begin{Desc}
\item[Remarks: ]\par
Also parses the request as necessary. \end{Desc}
\index{params@{params}!apreq_params@{apreq\_\-params}}
\index{apreq_params@{apreq\_\-params}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apr\_\-table\_\-t}$\ast$ apreq\_\-params ({\bf apr\_\-pool\_\-t} $\ast$ {\em p}, const {\bf apreq\_\-request\_\-t} $\ast$ {\em req})}\label{group__params_a7}


Returns a table containing key-value pairs for the full request (args + body). \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
p}]Allocates the returned table. \item[{\em 
req}]The current {\bf apreq\_\-request\_\-t} {\rm (p.\,\pageref{structapreq__request__t})} object. \end{description}
\end{Desc}
\begin{Desc}
\item[Remarks: ]\par
Also parses the request if necessary. \end{Desc}
\index{params@{params}!apreq_params_as_array@{apreq\_\-params\_\-as\_\-array}}
\index{apreq_params_as_array@{apreq\_\-params\_\-as\_\-array}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apr\_\-array\_\-header\_\-t}$\ast$ apreq\_\-params\_\-as\_\-array ({\bf apr\_\-pool\_\-t} $\ast$ {\em p}, {\bf apreq\_\-request\_\-t} $\ast$ {\em req}, const char $\ast$ {\em key})}\label{group__params_a8}


Returns an array of parameters ({\bf apreq\_\-param\_\-t} {\rm (p.\,\pageref{structapreq__param__t})} $\ast$) matching the given key. The key is case-insensitive. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
p}]Allocates the returned array. \item[{\em 
req}]The current {\bf apreq\_\-request\_\-t} {\rm (p.\,\pageref{structapreq__request__t})} object. \item[{\em 
key}]Null-terminated search key. key==NULL fetches all parameters. \end{description}
\end{Desc}
\begin{Desc}
\item[Remarks: ]\par
Also parses the request if necessary. \end{Desc}
\index{params@{params}!apreq_params_as_string@{apreq\_\-params\_\-as\_\-string}}
\index{apreq_params_as_string@{apreq\_\-params\_\-as\_\-string}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ apreq\_\-params\_\-as\_\-string ({\bf apr\_\-pool\_\-t} $\ast$ {\em p}, {\bf apreq\_\-request\_\-t} $\ast$ {\em req}, const char $\ast$ {\em key}, {\bf apreq\_\-join\_\-t} {\em mode})}\label{group__params_a9}


Returns a \char`\"{}, \char`\"{} -separated string containing all parameters  for the requested key, NULL if none are found. The key is case-insensitive. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
p}]Allocates the return string. \item[{\em 
req}]The current {\bf apreq\_\-request\_\-t} {\rm (p.\,\pageref{structapreq__request__t})} object. \item[{\em 
key}]Null-terminated parameter name. key==NULL fetches all values.  \item[{\em 
mode}]Join type- see {\bf apreq\_\-join}() {\rm (p.\,\pageref{group__Utils_a7})}. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returned string is the data attribute of an {\bf apreq\_\-value\_\-t} {\rm (p.\,\pageref{structapreq__value__t})}, so it is safe to use in {\bf apreq\_\-strlen}() {\rm (p.\,\pageref{group__Utils_a35})} and {\bf apreq\_\-strtoval}(). \end{Desc}
\begin{Desc}
\item[Remarks: ]\par
Also parses the request if necessary. \end{Desc}
\index{params@{params}!apreq_parse_query_string@{apreq\_\-parse\_\-query\_\-string}}
\index{apreq_parse_query_string@{apreq\_\-parse\_\-query\_\-string}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apr\_\-status\_\-t} apreq\_\-parse\_\-query\_\-string ({\bf apr\_\-pool\_\-t} $\ast$ {\em pool}, {\bf apr\_\-table\_\-t} $\ast$ {\em t}, const char $\ast$ {\em qs})}\label{group__params_a12}


Parse a url-encoded string into a param table. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
pool}]pool used to allocate the param data. \item[{\em 
table}]table to which the params are added. \item[{\em 
qs}]Query string to url-decode. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
APR\_\-SUCCESS if successful, error otherwise. \end{Desc}
\begin{Desc}
\item[Remarks: ]\par
This function uses [\&;] as the set of tokens to delineate words, and will treat a word w/o '=' as a name-value pair with value-length = 0. \end{Desc}
\index{params@{params}!apreq_parse_request@{apreq\_\-parse\_\-request}}
\index{apreq_parse_request@{apreq\_\-parse\_\-request}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apr\_\-status\_\-t} apreq\_\-parse\_\-request ({\bf apreq\_\-request\_\-t} $\ast$ {\em req}, {\bf apr\_\-bucket\_\-brigade} $\ast$ {\em bb})}\label{group__params_a13}


Parse a brigade as incoming POST data. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
req}]Current request. \item[{\em 
bb}]Brigade to parse. See remarks below. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
APR\_\-INCOMPLETE if the parse is incomplete, APR\_\-SUCCESS if the parser is finished (saw eos), unrecoverable error value otherwise. \end{Desc}
\index{params@{params}!apreq_parser@{apreq\_\-parser}}
\index{apreq_parser@{apreq\_\-parser}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apreq\_\-parser\_\-t}$\ast$ apreq\_\-parser ({\bf void} $\ast$ {\em env}, {\bf apreq\_\-hook\_\-t} $\ast$ {\em hook})}\label{group__params_a21}


Create the default parser associated with the current request's Content-Type (if possible). \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
env}]The current environment. \item[{\em 
hook}]Hook(s) to add to the parser. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
New parser, NULL if the Content-Type is unrecognized. {\bf apreq\_\-parser}() {\rm (p.\,\pageref{group__params_a21})} currently recognizes APREQ\_\-URL\_\-ENCTYPE and APREQ\_\-MFD\_\-ENCTYPE.\end{Desc}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
env}]The current environment. \item[{\em 
hook}]Additional hooks to supply the parser with. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
The built-in parser; NULL if the environment's Content-Type is unrecognized. \end{Desc}
\index{params@{params}!apreq_request@{apreq\_\-request}}
\index{apreq_request@{apreq\_\-request}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apreq\_\-request\_\-t}$\ast$ apreq\_\-request ({\bf void} $\ast$ {\em env}, const char $\ast$ {\em qs})}\label{group__params_a5}


Creates an {\bf apreq\_\-request\_\-t} {\rm (p.\,\pageref{structapreq__request__t})} object. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
env}]The current request environment. \item[{\em 
qs}]The query string. \end{description}
\end{Desc}
\begin{Desc}
\item[Remarks: ]\par
\char`\"{}qs = NULL\char`\"{} has special behavior. In this case, apreq\_\-request(env,NULL) will attempt to fetch a cached object from the environment via apreq\_\-env\_\-request. Failing that, it will replace \char`\"{}qs\char`\"{} with the result of apreq\_\-env\_\-query\_\-string(env),  parse that, and store the resulting {\bf apreq\_\-request\_\-t} {\rm (p.\,\pageref{structapreq__request__t})} object back  within the environment. This maneuver is designed to both mimimize parsing work and allow the environent to place the parsed POST data in req-$>$body (otherwise the caller may need to do this manually). For details on this, see the environment's documentation for the apreq\_\-env\_\-read function. \end{Desc}
\index{params@{params}!apreq_upload@{apreq\_\-upload}}
\index{apreq_upload@{apreq\_\-upload}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apreq\_\-param\_\-t}$\ast$ apreq\_\-upload (const {\bf apreq\_\-request\_\-t} $\ast$ {\em req}, const char $\ast$ {\em key})}\label{group__params_a15}


Returns the first param in req-$>$body which has both param-$>$v.name  matching key and param-$>$bb != NULL. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
req}]The current request. \item[{\em 
key}]Parameter name. key == NULL returns first upload. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Corresponding upload, NULL if none found. \end{Desc}
\begin{Desc}
\item[Remarks: ]\par
Will parse the request as necessary. \end{Desc}
\index{params@{params}!apreq_uploads@{apreq\_\-uploads}}
\index{apreq_uploads@{apreq\_\-uploads}!params@{params}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf apr\_\-table\_\-t}$\ast$ apreq\_\-uploads ({\bf apr\_\-pool\_\-t} $\ast$ {\em pool}, const {\bf apreq\_\-request\_\-t} $\ast$ {\em req})}\label{group__params_a14}


Returns a table of all params in req-$>$body with non-NULL bucket brigades. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
pool}]Pool which allocates the table struct. \item[{\em 
req}]Current request. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Upload table. \end{Desc}
\begin{Desc}
\item[Remarks: ]\par
Will parse the request if necessary. \end{Desc}
